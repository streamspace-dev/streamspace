# P2 BUG REPORT: CSRF Protection Blocking Programmatic API Access

**Bug ID**: P2-004
**Severity**: P2 (Medium)
**Status**: Open
**Discovered**: 2025-11-21
**Component**: API - CSRF Middleware
**Affects**: Programmatic API clients (curl, scripts, automation)

---

## Executive Summary

The StreamSpace v2.0-beta API has CSRF protection enabled, but the login endpoint does not set CSRF cookies. This blocks programmatic API clients from creating sessions via POST requests, as they cannot obtain the required CSRF token.

---

## Problem Statement

When attempting to create a session programmatically via the API using curl or scripts, requests are rejected with:

```json
{
  "error": "CSRF token missing",
  "message": "CSRF cookie not found"
}
```

This occurs even with valid JWT authentication because:
1. The login endpoint (`POST /api/v1/auth/login`) does not set a CSRF cookie
2. Protected endpoints (e.g., `POST /api/v1/sessions`) require both a CSRF cookie and CSRF token header
3. Programmatic clients have no way to obtain a CSRF token

---

## Reproduction Steps

### 1. Login and Get JWT Token

```bash
TOKEN=$(curl -s -X POST http://localhost:8000/api/v1/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"username":"admin","password":"<admin-password>"}' | jq -r '.token')

echo "Token: $TOKEN"
```

**Result**: Successfully receives JWT token.

### 2. Attempt to Create Session

```bash
curl -X POST http://localhost:8000/api/v1/sessions \
  -H "Authorization: Bearer $TOKEN" \
  -H 'Content-Type: application/json' \
  -d '{
    "user": "admin",
    "template": "firefox-browser",
    "resources": {"memory": "1Gi", "cpu": "500m"},
    "persistentHome": false
  }'
```

**Expected**: Session is created successfully.

**Actual**:
```json
{
  "error": "CSRF token missing",
  "message": "CSRF cookie not found"
}
```

### 3. Check for CSRF Cookie

```bash
# Try saving cookies from login
curl -s -c cookies.txt -X POST http://localhost:8000/api/v1/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"username":"admin","password":"<password>"}'

cat cookies.txt | grep csrf
```

**Expected**: CSRF cookie is set by login endpoint.

**Actual**: No CSRF cookie in cookies file. Login endpoint doesn't set CSRF cookies.

---

## Root Cause

### CSRF Middleware Configuration

The API has CSRF middleware enabled (`api/cmd/main.go:454`), but the login endpoint doesn't participate in CSRF token generation:

```go
// CSRF middleware is applied globally
router.Use(csrf.Middleware(csrf.Config{
    TokenLookup: "header:X-CSRF-Token",
    CookieName:  "_csrf",
    CookiePath:  "/",
}))
```

### Login Endpoint Behavior

The login endpoint (`POST /api/v1/auth/login`) returns a JWT token but does not:
- Set a `_csrf` cookie
- Return a CSRF token in the response body
- Provide any mechanism for clients to obtain CSRF tokens

### Protected Endpoint Requirements

Protected endpoints like `POST /api/v1/sessions` require:
1. **JWT Token**: Provided via `Authorization: Bearer <token>` header ✅
2. **CSRF Cookie**: Set by server (missing) ❌
3. **CSRF Token**: Provided via `X-CSRF-Token` header (cannot obtain without cookie) ❌

---

## Impact Assessment

### Severity: P2 (Medium)

**Why P2 and Not P0**:
- This affects programmatic API clients, not web UI users
- Web browsers automatically handle CSRF cookies and tokens
- This is a configuration issue, not a core functionality bug
- Workarounds exist (API keys, direct CRD creation)

**Affected Use Cases**:
- ❌ CLI tools and scripts (curl, Python clients)
- ❌ CI/CD automation
- ❌ Integration tests via API
- ❌ Third-party integrations
- ✅ Web UI (works fine - browsers handle CSRF automatically)

**Not Affected**:
- Web UI users (CSRF tokens work in browsers)
- `kubectl` users (can create Session CRDs directly)
- Internal service-to-service calls (should bypass CSRF)

---

## Evidence

### 1. Login Request (Success)

```bash
$ curl -s -c cookies.txt -X POST http://localhost:8000/api/v1/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"username":"admin","password":"83nXgy87RL2QBoApPHmJagsfKJ4jc467"}'

{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresAt": "2025-11-22T18:02:40.770306979Z",
  "user": {
    "id": "admin",
    "username": "admin",
    "email": "admin@streamspace.local",
    "role": "admin"
  }
}
```

### 2. Cookies File (No CSRF Cookie)

```bash
$ cat cookies.txt
# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

# (Empty - no cookies set)
```

### 3. Session Creation (CSRF Error)

```bash
$ curl -s -b cookies.txt -X POST http://localhost:8000/api/v1/sessions \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-CSRF-Token: " \
  -H 'Content-Type: application/json' \
  -d '{"user":"admin","template":"firefox-browser","resources":{"memory":"1Gi","cpu":"500m"},"persistentHome":false}'

{
  "error": "CSRF token missing",
  "message": "CSRF cookie not found"
}
```

### 4. API Logs

```
$ kubectl logs -n streamspace deploy/streamspace-api --tail=10 | grep CSRF
2025/11/21 18:15:38 WARN map[client_ip:127.0.0.1 duration:137.17µs method:POST path:/api/v1/sessions status:401]
2025/11/21 18:20:51 WARN map[client_ip:127.0.0.1 duration:4.11ms method:POST path:/api/v1/sessions status:403 user_id:admin]
```

---

## Recommended Solution

### Option 1: Add CSRF Token to Login Response (Preferred)

Modify the login endpoint to generate and return a CSRF token:

```go
// In login handler (api/internal/handlers/auth.go)
func (h *AuthHandler) Login(c *gin.Context) {
    // ... existing login logic ...

    // Generate CSRF token
    csrfToken := csrf.Token(c)

    // Set CSRF cookie
    c.SetCookie(
        "_csrf",         // name
        csrfToken,       // value
        3600,            // maxAge (1 hour)
        "/",             // path
        "",              // domain
        false,           // secure
        true,            // httpOnly
    )

    // Return token in response
    c.JSON(http.StatusOK, gin.H{
        "token":      jwtToken,
        "csrfToken":  csrfToken,  // NEW
        "expiresAt":  expiresAt,
        "user":       userDTO,
    })
}
```

**Usage**:
```bash
# Login and save both JWT and CSRF tokens
RESPONSE=$(curl -s -c cookies.txt -X POST http://localhost:8000/api/v1/auth/login ...)
TOKEN=$(echo "$RESPONSE" | jq -r '.token')
CSRF_TOKEN=$(echo "$RESPONSE" | jq -r '.csrfToken')

# Use both tokens in subsequent requests
curl -X POST http://localhost:8000/api/v1/sessions \
  -b cookies.txt \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-CSRF-Token: $CSRF_TOKEN" \
  ...
```

### Option 2: Exempt API Clients from CSRF (Alternative)

Add CSRF exemption for requests with API keys or JWT tokens:

```go
// In CSRF middleware configuration
router.Use(csrf.Middleware(csrf.Config{
    TokenLookup: "header:X-CSRF-Token",
    CookieName:  "_csrf",
    CookiePath:  "/",
    // Exempt requests with X-API-Key or Authorization header
    Skipper: func(c *gin.Context) bool {
        return c.GetHeader("X-API-Key") != "" ||
               c.GetHeader("Authorization") != ""
    },
}))
```

**Pros**: Simple fix, no changes to login endpoint.

**Cons**: Reduces CSRF protection for authenticated requests.

### Option 3: Add Dedicated API Key Endpoint (Best for Production)

Create a separate authentication flow for API clients using long-lived API keys:

```go
// New endpoint: POST /api/v1/auth/api-keys
// Returns API key that bypasses CSRF

// API clients use X-API-Key header instead of JWT
```

**Pros**: Best practice for API clients, maintains CSRF for web.

**Cons**: Requires new endpoint and API key management UI.

---

## Workarounds

### Workaround 1: Use kubectl to Create Sessions

Instead of using the API, create Session CRDs directly:

```bash
kubectl apply -f - <<EOF
apiVersion: stream.space/v1alpha1
kind: Session
metadata:
  name: my-session
  namespace: streamspace
spec:
  user: admin
  template: firefox-browser
  state: running
  resources:
    requests:
      memory: 1Gi
      cpu: 500m
EOF
```

**Limitation**: Requires kubectl access, not suitable for end users or integrations.

### Workaround 2: Disable CSRF Middleware (Dev Only)

For development/testing, temporarily disable CSRF:

```go
// In api/cmd/main.go - comment out CSRF middleware
// router.Use(csrf.Middleware(...))
```

**⚠️ WARNING**: DO NOT use in production. Only for local dev/testing.

---

## Testing Plan

Once fixed:

### 1. Login and Save Cookies

```bash
RESPONSE=$(curl -s -c cookies.txt -X POST http://localhost:8000/api/v1/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"username":"admin","password":"<password>"}')

TOKEN=$(echo "$RESPONSE" | jq -r '.token')
CSRF_TOKEN=$(echo "$RESPONSE" | jq -r '.csrfToken')
```

**Expected**: Both JWT token and CSRF token are returned.

### 2. Verify CSRF Cookie Set

```bash
cat cookies.txt | grep csrf
```

**Expected**: CSRF cookie exists in cookies file.

### 3. Create Session with CSRF Token

```bash
curl -s -b cookies.txt -X POST http://localhost:8000/api/v1/sessions \
  -H "Authorization: Bearer $TOKEN" \
  -H "X-CSRF-Token: $CSRF_TOKEN" \
  -H 'Content-Type: application/json' \
  -d '{"user":"admin","template":"firefox-browser","resources":{"memory":"1Gi","cpu":"500m"},"persistentHome":false}' | jq .
```

**Expected**: Session is created successfully (returns session object with ID).

### 4. Verify Session Created

```bash
curl -s -b cookies.txt -H "Authorization: Bearer $TOKEN" \
  http://localhost:8000/api/v1/sessions | jq .
```

**Expected**: Session appears in list.

---

## Related Issues

- **P0-003**: Missing Kubernetes Controller (blocks session provisioning regardless of CSRF fix)
- **P1-002**: Admin Authentication Failure (FIXED)

---

## Recommendation

**Priority**: P2 (should fix before v2.0-beta release, but not blocking)

**Recommended Solution**: Option 1 (Add CSRF token to login response)

**Timeline**: 2-3 hours for implementation and testing

**Impact After Fix**: Programmatic API clients can create sessions via API

---

**Reporter**: Claude Code (Validator)
**Date**: 2025-11-21
**Branch**: `claude/v2-validator`
